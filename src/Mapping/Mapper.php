<?php

namespace NanoFrm\Mapping;

use NanoFrm\Utilities\TypeCheck\DynamicProxy;
use NanoFrm\Utilities\TypeCheck\PropertyHandler;

class Field {

    public $parentClass;
    public $fieldName;
    public $fieldType;

    public $primaryKey;
    public $autoGenerated;
    
    public $foreignClass;
    public $foreignFieldName;

}

class FieldDefinition {
    
    protected $parentClass;
    protected $fieldName;
    protected $fieldType;

    protected $primaryKey = false;
    protected $autoGenerated = false;
    
    protected $foreignClass;
    protected $foreignFieldName;

    public function __construct($parentClass, $fieldName) {
        
        $this->parentClass = $parentClass;
        $this->fieldName = $fieldName;
        
        $this->fieldType = FieldDefinition::getPropertyType($parentClass, $fieldName);
    }
    
    public function referenceTo(\Closure $foreignPropertyAccess){
        
        $fieldDefinition = FieldDefinition::fromClosure($foreignPropertyAccess);

        $this->foreignClass = $fieldDefinition->parentClass;        
        $this->foreignFieldName = $fieldDefinition->fieldName;
    }
    
    public function primaryKey() : FieldDefinition {
        $this->primaryKey = true;
        return $this;
    }
    
    public function autoGenerated() : FieldDefinition {
        $this->autoGenerated = true;
        return $this;
    }

    public function getFieldName() {
        return $this->fieldName;
    }

    public function getState() : Field {
        
        $field = new Field;
        
        $field->parentClass = $this->parentClass;
        $field->fieldName = $this->fieldName;
        $field->fieldType = $this->fieldType;

        $field->primaryKey = $this->primaryKey;
        $field->autoGenerated = $this->autoGenerated;

        $field->foreignClass = $this->foreignClass;
        $field->foreignFieldName = $this->foreignFieldName;
        
        return $field;
    }

    protected static function getPropertyType($className, $propertyName){
        
        $reflector = new \ReflectionClass($className);
        $refProperty = $reflector->getProperty($propertyName); 
        
        preg_match('/@var\s+([^\s]+)/', $refProperty->getDocComment(), $matches);
        
        if(count($matches) > 0){
            return $matches[1];
        }
        
        return null;
    }

    public static function fromClosure(\Closure $closure) : FieldDefinition{
        
        $reflector = new \ReflectionFunction($closure);

        $parentClassName = null;
        $paramName = null;

        foreach ($reflector->getParameters() as $param) {
            $paramName = $param->name;
            
            // param type hint (or null, if not specified).
            if($param->hasType()){
                $parentClassName = $param->getClass()->name;
            }
            
            break; // first
        }

        if($parentClassName == null){
            throw new \InvalidArgumentException("Accessor function does not have param type hint specified for param " . $paramName . "."); 
        }
        
        $propertyHandler = new class implements PropertyHandler {
          
            public $lastCalledProperty;
            
            public function handleProperty($operation, $propertyName, $propertyValue) {
                $this->lastCalledProperty = $propertyName;
            }
        };
        
        $paramProxy = DynamicProxy::proxy($parentClassName, $propertyHandler);
        
        call_user_func_array($closure, array($paramProxy));
        
        if($propertyHandler->lastCalledProperty == null){
            throw new \InvalidArgumentException("Accessor function body does not call a property of param " . $paramName . "."); 
        }
        
        return new FieldDefinition($parentClassName, $propertyHandler->lastCalledProperty);
    }
}

abstract class ClassMap {
    
    private $lastParentClass;
    private $lastPropertyHandler;
    private $fields = array();

    protected function fromClass($className){
        
        $this->lastParentClass = $className;
        
        $this->lastPropertyHandler = new class implements PropertyHandler {
            
            public $lastPropertyName;

            public function handleProperty($operation, $propertyName, $propertyValue) {

                $this->lastPropertyName = $propertyName;
                
            }
            
        };
        
        return DynamicProxy::proxy($className, $this->lastPropertyHandler);
    }

    public abstract function map();
    
    protected function field($fieldAccess) : FieldDefinition {
        
        $lastPropertyName = $this->lastPropertyHandler->lastPropertyName;
        $newField = new FieldDefinition($this->lastParentClass, $lastPropertyName);
        
        array_push($this->fields, $newField);
        
        return $newField;
    }
    
    protected function fieldFn($fieldAccessFn) : FieldDefinition {
         $newField = FieldDefinition::fromClosure($fieldAccessFn);
         
         array_push($this->fields, $newField);
         
         return $newField;
    }

    public function getFields(){
        return $this->fields;
    }

    public function getField($fieldName) : FieldDefinition {
        
        foreach($this->getFields() as $fieldDef){
            if($fieldDef->getFieldName() == $fieldName){
                return $fieldDef;
            }
        }
        
        return null;
    }

}

/**
 * Description of Mapper
 *
 * @author cleber.zanella
 */
class Mapper {
    //put your code here
}
